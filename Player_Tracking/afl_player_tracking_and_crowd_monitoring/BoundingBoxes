# -*- coding: utf-8 -*-
"""boundingboxeswithevents.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qjF8riAPbImWdy3NhnVNWT4C_vacw1j-
"""

import cv2
import json
import numpy as np
import pandas as pd

kick = pd.read_csv('kick_synced_annotations.csv')
kick = pd.DataFrame(kick)

kick.head()

#reading the event data and storing it as a pandas data frame
event = pd.read_csv('mark_synced_annotations.csv')
event = pd.DataFrame(event)


#reading the tracking data
with open('mark_1 1track.json', 'r') as f:
    annotations = json.load(f)

# reading the raw video
video_path = 'mark_1.mp4'
cap = cv2.VideoCapture(video_path)


fps = int(cap.get(cv2.CAP_PROP_FPS))
width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))

# output video
output_path = 'mark_1_event.mp4'
fourcc = cv2.VideoWriter_fourcc(*'mp4v')
out = cv2.VideoWriter(output_path, fourcc, fps, (width, height))


# initiating the frame index as 0
frame_index = 0



while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        break
    # iterating through traking data for each frame
    if annotations['tracking_results'][frame_index]['frame_number'] == frame_index + 1:
      #iterating through each object in the tracking results
        for box in annotations['tracking_results'][frame_index]['players']:
            x1, y1, x2, y2 = box['bbox']['x1'], box['bbox']['y1'], box['bbox']['x2'], box['bbox']['y2']
            # Rectangle around the player, co-ordinants of box (x1, y1), (x2, y2), Box colour (255, 255, 0) Box Thickness = 2
            cv2.rectangle(frame, (x1, y1), (x2, y2), (255, 255, 0), 2)
            # box for label below the player
            cv2.rectangle(frame, (x1, y2), (x1 +115, y2 +50), (255, 255, 0), -1)
            # label for player only displaying the player ID to prevent the frame being over populated with information
            cv2.putText(frame, str(box['player_id']), (x1, y2 +45), cv2.FONT_HERSHEY_PLAIN, 4, (255, 255, 255), 3)

            # for each frame the event data is checked
            valid_event_rows = event.dropna(subset=['x1', 'y1', 'x2', 'y2'])
            for index, row in valid_event_rows.iterrows():
             # if the data matches the current frame it is checked for if it is an error or not it is then given a green or red box based off this information
              if row['frame_id'] == frame_index + 1:
                if row['error'] == 'Yes':
                  cv2.rectangle(frame, (int(row['x1']), int(row['y1'])), (int(row['x2']), int(row['y2'])), (0, 0, 255), 2)
                  cv2.putText(frame, 'Error', (int(row['x1']), int(row['y1']) +45), cv2.FONT_HERSHEY_PLAIN, 4, (0, 0, 255), 3)
                else:
                  cv2.rectangle(frame, (int(row['x1']), int(row['y1'])), (int(row['x2']), int(row['y2'])), (0, 255, 0), 2)
                  cv2.putText(frame, str(row['event_name']), (int(row['x1']), int(row['y1']) +45), cv2.FONT_HERSHEY_PLAIN, 4, (0, 255, 0), 3)
                  cv2.putText(frame, 'player ID: '+ str(row['player_id']) + ' Event: ' + str(row['event_name']), (50, 150), cv2.FONT_HERSHEY_PLAIN, 4, (0, 255, 0), 3)


    # writing to the new output video
    out.write(frame)

    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

    frame_index += 1

cap.release()
out.release()
cv2.destroyAllWindows()
